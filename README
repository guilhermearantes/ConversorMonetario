# üí∏ Desafio Java ‚Äì Banco Inter

Este projeto implementa um servi√ßo de remessa entre usu√°rios Pessoa F√≠sica (PF) e Pessoa Jur√≠dica (PJ), com convers√£o autom√°tica de Real para D√≥lar e controle de limites di√°rios por tipo de usu√°rio.

---

## üì¶ Tecnologias Utilizadas

- Java 17
- Spring Boot 3.x
- Spring Data JPA
- Jakarta Bean Validation
- H2 Database (Banco de dados em mem√≥ria)
- Lombok
- Maven
- Docker
- Kubernetes

---

## üöÄ Como Compilar e Executar a Aplica√ß√£o

### Pr√©-requisitos

- Java 17+
- Maven 3.8+
- (Opcional) Docker

### Passo a Passo

```bash
git clone https://github.com/seu-usuario/seu-repositorio.git
cd seu-repositorio
mvn clean install
mvn spring-boot:run
```

A aplica√ß√£o estar√° dispon√≠vel em:

- API: `http://localhost:8080`

### Console H2 (opcional):

- URL: `http://localhost:8080/h2-console`
- JDBC URL: `jdbc:h2:mem:remessa-db`
- Usu√°rio: `sa`
- Senha: *(em branco)*

---

## üß™ Como Executar os Testes Unit√°rios

```bash
mvn test
```

---

## üìÑ Funcionalidades Principais

- Cadastro de usu√°rios PF e PJ com valida√ß√µes:
  - E-mail, CPF e CNPJ √∫nicos
- Carteiras com saldo em BRL e USD
- Remessa entre usu√°rios:
  - Convers√£o de BRL para USD com cota√ß√£o oficial via Banco Central
  - Verifica√ß√£o de limites di√°rios (10 mil para PF, 50 mil para PJ)
  - Transfer√™ncia com rollback total em caso de erro
  - Uso da √∫ltima cota√ß√£o dispon√≠vel em finais de semana e feriados
- Tratamento de erros com mensagens claras e status HTTP adequados
- Opera√ß√µes totalmente transacionais

---

## üîç Decis√µes T√©cnicas e Arquiteturais

### Arquitetura e Design
- O projeto foi estruturado seguindo uma arquitetura em camadas clara (Controller -> Service -> Repository), facilitando a manuten√ß√£o e testabilidade
- Utilizamos DTOs para separar a camada de API da camada de dom√≠nio, evitando exposi√ß√£o desnecess√°ria de detalhes de implementa√ß√£o
- A escolha do Spring Boot foi motivada pela necessidade de criar uma API RESTful robusta com r√°pido desenvolvimento
- Implementamos o padr√£o Builder extensivamente (via Lombok) para facilitar a cria√ß√£o de objetos, especialmente √∫til nos testes

### Banco de Dados
- Optamos pelo H2 por ser um banco em mem√≥ria ideal para testes e desenvolvimento, al√©m de n√£o exigir configura√ß√£o adicional para avalia√ß√£o do desafio
- As entidades foram modeladas pensando em transa√ß√µes e hist√≥rico (ex: CotacaoHistorico para manter registro de cota√ß√µes)

### Tratamento de Regras de Neg√≥cio
- Implementamos o controle de limites di√°rios (10k PF/50k PJ) utilizando uma tabela espec√≠fica de transa√ß√µes di√°rias
- A l√≥gica de cota√ß√£o foi desenvolvida com fallback para finais de semana, consultando a √∫ltima cota√ß√£o √∫til dispon√≠vel
- Todas as opera√ß√µes de remessa s√£o transacionais (com @Transactional) garantindo atomicidade

### Testes
- Criamos uma hierarquia de testes com TestBase compartilhando configura√ß√µes comuns
- Utilizamos um TestDataBuilder para facilitar a cria√ß√£o de dados de teste
- Os testes de integra√ß√£o utilizam um contexto real do Spring, garantindo que todas as camadas funcionem em conjunto

### Container e Kubernetes
- A aplica√ß√£o foi containerizada usando Docker com uma imagem base do OpenJDK 17
- No Kubernetes, implementamos:
  - Alta disponibilidade com 2 r√©plicas
  - Rolling updates para deploys sem downtime
  - ConfigMap para externaliza√ß√£o de configura√ß√µes

---
